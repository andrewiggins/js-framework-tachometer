{"version":3,"file":"afterframe.module.js","sources":["../src/index.js"],"sourcesContent":["/**\r\n * Queue of functions to invoke\r\n * @type {Array<(time: number) => void>}\r\n */\r\nlet callbacks = [];\r\n\r\nconst channel = new MessageChannel();\r\n\r\n// Flush the callback queue when a message is posted to the message channel\r\nchannel.port1.onmessage = () => {\r\n  // Reset the callback queue to an empty list in case callbacks call\r\n  // afterFrame. These nested calls to afterFrame should queue up a new\r\n  // callback to be flushed in the following frame and should not impact the\r\n  // current queue being flushed\r\n  let toFlush = callbacks;\r\n  callbacks = [];\r\n  let time = performance.now();\r\n  for (let i = 0; i < toFlush.length; i++) {\r\n    // Call all callbacks with the time the flush began, similar to requestAnimationFrame\r\n    // TODO: Error handling?\r\n    toFlush[i](time);\r\n  }\r\n};\r\n\r\nfunction postMessage() {\r\n  channel.port2.postMessage(undefined);\r\n}\r\n\r\n/**\r\n * Invoke the given callback after the browser renders the next frame\r\n * @param {(time: number) => void} callback The function to call after the browser renders\r\n * the next frame. The callback function is passed one argument, a DOMHighResTimeStamp\r\n * similar to the one returned by performance.now(), indicating the point in time when\r\n * afterFrame() starts to execute callback functions.\r\n */\r\nexport default function afterFrame(callback) {\r\n  if (callbacks.push(callback) === 1) {\r\n    requestAnimationFrame(postMessage);\r\n  }\r\n}\r\n"],"names":["let","callbacks","channel","MessageChannel","postMessage","port2","undefined","port1","onmessage","toFlush","time","performance","now","i","length","callback","push","requestAnimationFrame"],"mappings":"AAIAA,IAAIC,EAAY,GAEVC,EAAU,IAAIC,eAkBpB,SAASC,IACPF,EAAQG,MAAMD,iBAAYE,GAhB5BJ,EAAQK,MAAMC,yBAKRC,EAAUR,EACdA,EAAY,WACRS,EAAOC,YAAYC,MACdC,EAAI,EAAGA,EAAIJ,EAAQK,OAAQD,IAGlCJ,EAAQI,GAAGH,mBAeA,SAAoBK,GACA,IAA7Bd,EAAUe,KAAKD,IACjBE,sBAAsBb"}